<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>I used Machine Learning to Beat the Roblox Interview Game - Adam Kulikowski</title>
    <link rel="canonical" href="https://adamkulik.com/blog/kaijugo">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><text y='50%' x='50%' text-anchor='middle' dominant-baseline='central' font-size='48'>üè¥‚Äç‚ò†Ô∏è</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            line-height: 1.65;
            color: #1a1a1a;
            background: #fff;
        }

        .site-header {
            padding: 20px 0;
            border-bottom: 1px solid #e5e5e5;
            margin-bottom: 60px;
        }

        .site-header a {
            color: #1a1a1a;
            text-decoration: none;
            font-size: 14px;
            padding: 0 40px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 40px;
            position: relative;
        }

        /* Background decorative images - positioned to the sides */
        .banner-container {
            position: absolute;
            width: 100%;
            height: 600px;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 0;
        }

        .bg-decoration {
            position: absolute;
            opacity: 1;
            pointer-events: none;
        }

        .bg-decoration.left {
            top: 40px;
            left: 20px;
            width: 160px;
            transform: rotate(-12deg);
        }

        .bg-decoration.center {
            top: 0px;
            right: 40px;
            width: 150px;
            transform: rotate(10deg);
        }

        .bg-decoration.right {
            top: 230px;
            right: 60px;
            width: 170px;
            transform: rotate(-8deg);
        }

        /* Table of Contents */
        .toc {
            float: left;
            width: 200px;
            margin-right: 60px;
            margin-top: 280px;
            position: sticky;
            top: 40px;
            z-index: 1;
        }

        .toc h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #666;
            margin-bottom: 16px;
            font-weight: 600;
        }

        .toc ul {
            list-style: none;
        }

        .toc li {
            margin-bottom: 10px;
        }

        .toc a {
            color: #666;
            text-decoration: none;
            font-size: 13px;
            transition: color 0.2s;
        }

        .toc a:hover {
            color: #1a1a1a;
        }

        .toc ul ul {
            margin-left: 16px;
            margin-top: 8px;
        }

        .toc ul ul li {
            margin-bottom: 6px;
        }

        /* Main Content */
        .content {
            margin-left: 260px;
            max-width: 720px;
            position: relative;
            z-index: 1;
        }

        .content header {
            margin-bottom: 50px;
        }

        h1 {
            font-size: 48px;
            font-weight: 700;
            line-height: 1.1;
            margin-bottom: 16px;
            color: #1a1a1a;
        }

        .description {
            font-size: 18px;
            color: #666;
            font-style: italic;
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .meta {
            color: #888;
            font-size: 14px;
        }

        .meta .author {
            margin-right: 8px;
        }

        h2 {
            font-size: 32px;
            font-weight: 700;
            margin-top: 60px;
            margin-bottom: 20px;
            color: #1a1a1a;
        }

        h3 {
            font-size: 24px;
            font-weight: 600;
            margin-top: 40px;
            margin-bottom: 16px;
            color: #1a1a1a;
        }

        p {
            margin-bottom: 20px;
            color: #333;
            font-size: 16px;
            line-height: 1.7;
        }

        strong {
            font-weight: 600;
        }

        code {
            background: #f5f5f5;
            padding: 3px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            color: #d73a49;
        }

        pre {
            background: #f5f5f5;
            padding: 16px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 24px 0;
            border-left: 3px solid #ddd;
        }

        pre code {
            background: none;
            padding: 0;
            color: #333;
        }

        hr {
            border: none;
            border-top: 1px solid #e5e5e5;
            margin: 50px 0;
        }

        .footer-note {
            color: #888;
            font-size: 14px;
            font-style: italic;
            margin-top: 50px;
            padding-top: 30px;
            border-top: 1px solid #e5e5e5;
        }

        .footer-note a {
            color: #888;
            text-decoration: none;
        }

        .footer-note a:hover {
            text-decoration: underline;
        }

        .highlight-box {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 6px;
            margin: 30px 0;
            color: #666;
            font-size: 15px;
            line-height: 1.6;
            border-left: 3px solid #ddd;
        }

        .image-container {
            margin: 30px 0;
            text-align: center;
        }

        .image-container img {
            max-width: 100%;
            height: auto;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .image-subtext {
            margin-top: 12px;
            color: #666;
            font-size: 14px;
            font-style: italic;
            line-height: 1.5;
        }

        /* Responsive */
        @media (max-width: 968px) {
            .toc {
                float: none;
                width: 100%;
                position: static;
                margin-bottom: 40px;
                margin-right: 0;
            }

            .content {
                margin-left: 0;
            }

            h1 {
                font-size: 36px;
            }

            .bg-decoration {
                display: none;
            }
        }
    </style>
</head>
<body>
    <header class="site-header">
        <a href="../index.html">‚Üê Back to Main</a>
    </header>

    <div class="container">
        <!-- Background decorative images -->
        <div class="banner-container">
            <img src="ml-post-images/one.png" class="bg-decoration left" alt="">
            <img src="ml-post-images/two.png" class="bg-decoration center" alt="">
            <img src="ml-post-images/three.png" class="bg-decoration right" alt="">
        </div>

        <!-- Table of Contents -->
        <nav class="toc">
            <h3>Table of Contents</h3>
            <ul>
                <li><a href="#intro">The Challenge</a></li>
                <li><a href="#possible">Is This Even Possible?</a></li>
                <li><a href="#approach">My First Approach</a></li>
                <li><a href="#simulator">The Problems</a></li>
                <li><a href="#ml">The Machine Learning</a></li>
                <li><a href="#results">Results</a></li>
                <li><a href="#ethics">Ethics Disclaimer</a></li>
            </ul>
        </nav>

        <!-- Main Content -->
        <article class="content">
            <header>
                <h1>I used Machine Learning to Beat the Roblox Interview Game</h1>

                <div class="description">
                    Building a game-playing AI to solve Kaiju Cats and exploring the challenges of simulation, optimization, and speed
                </div>

                <div class="meta">
                    <span class="author"><a href="../index.html" style="color: inherit; text-decoration: none;">Adam Kulikowski</a></span>
                    <time datetime="2025-10-24">October 24, 2025</time>
                </div>
            </header>

            <div class="article-content">
                <h2 id="intro">The Challenge</h2>

                <p>Unlike most other companies, Roblox takes a bit of a different approach when it comes to interviews. Instead of the classic Leetcode coding style assessments, they use problem solving games. One of these games is called Kaiju Cats. It's a game where you control the movement of 3 cats and try to maximize the amount of points they get as they move around the board.</p>

                <p>After learning about popular machine learning algorithms like Deep Blue and Alpha Go in my university class, I wanted to create something similar that could learn and master this game. I was initially thinking of using a reinforcement approach: simulate millions of games and use either random forest or a neural net style algorithm to develop heuristics for solving games.</p>

                <h2 id="rules">Rules of the Game</h2>

                <p>The primary objective is to maximize the combined power of three cats within a hard limit of 15 turns. Player actions are defined by attaching commands to "Attachment Points" on building floors, which directs the cats' movement through the city. Cats gain fixed power values for destroying standard building floors, but can also destroy "Power Plants" to double their current power. The grid also features traps that modify a cat's state or score: Mud (stuck for one turn), Spike Traps (halves current power), and Boulders (reverses direction). The game concludes as cats reach their matching beds, applying a critical, order-based bonus: the first cat gets +2,000 power, the second multiplies its power by 3, and the third multiplies its power by 5.</p>

                <p>You can play the game on Roblox here: <a href="https://www.roblox.com/games/13977123257/Kaiju-Cats" style="color: inherit; text-decoration: underline;">https://www.roblox.com/games/13977123257/Kaiju-Cats</a></p>

                <div class="image-container">
                    <img src="ml-post-images/start.png" alt="Kaiju Cats Game">
                </div>

                <h2 id="possible">Is This Even Possible?</h2>

                <p>To start off, I had to ask myself the question of is this even possible? Upon my quick initial count there are 25-30 squares where you can place movement tiles (I later found out it's 31!). Also we are looking for the combinations here not permutations: (Left, Stomp, Right) is going to be very different from (Right, Stomp, Left) even though they use the same commands.</p>

                <p>Since each tile can be one of 6 commands (up, down, left, right, stomp, powerup), that's 6 possible choices for each square. I assumed 30 just for simplicity.</p>

                <p>That means that there is a possibility of 6<sup>30</sup> combinations a game can have.</p>

                <div class="highlight-box">
                    If you're curious, that's: 61,159,090,448,414,546,283,439,041 possible combinations.<br>
                    That's 8 million times the number of grains of sand on earth.
                </div>

                <p>Yeah not a good initial sign‚Ä¶</p>

                <p>But, before I threw this project away as impossible, I considered chess algorithms. The average branching factor, or the number of possible moves for each chess move, is 35. That's a lot worse than 6. Basic chess algorithms written by amateurs are able to play at a beginner to intermediate level. So why couldn't I devise a Kaiju engine that could play at an equally beginner to intermediate level?</p>

                <h2 id="approach">My First Approach</h2>

                <p>My first challenge in this project was how to even approach the problem. Could it even be solved? As with all machine learning, I started to think about what would be the goal metric? How could I measure how good my algorithm was performing? How would I prune off combinations of movements from the game, as searching all of them was infeasible?</p>

                <h2 id="simulator">The Problems</h2>

                <p>There were several problems with this approach:</p>

                <p>The game map changes with each play. This means that some heuristics which work well on some maps might not work on other maps.</p>

                <p>Machine learning algorithms require huge datasets. There is no automated way to run the game millions of times, so how could I gather a large enough dataset to make any ML algorithm work?</p>

                <p>The most obvious of these problems was that since this was a game designed to be played by people, there was no way to run this game millions (if not more) times. Manually loading the game and recording the state takes about 1-2 minutes. Since I don't have 1-2 million minutes of free time, I had to look for another approach.</p>

                <div class="image-container">
                    <video autoplay loop muted playsinline style="max-width: 70%; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <source src="ml-post-images/init_play.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <div class="image-subtext">
                        Sample solution from the kaiju game gameplay
                    </div>
                </div>

                <p>So I decided to go for another approach: build a simulator which could accurately simulate a game's map, then use machine learning to run millions of simulations on that specific game map to find the map's most optimal score.</p>

                <h3>Speed Matters</h3>

                <p>So I started building the simulator in Python because I figured it would be simple and easy to build. Big mistake. Part way through building it, one of my friends brought up that speed would be of the utmost importance in this project. A difference in speed of the simulator of even a few milliseconds would be compounded over the millions of iterations I would need to run. Here's a cool graph online I found showing this problem:</p>

                <div class="image-container">
                    <img src="ml-post-images/programming_language_comparison.png" alt="Programming Language Speed Comparison" style="max-width: 55%;">
                </div>

                <p>Now I don't know C well enough to build this out, but I did several undergrad classes in Java, so I felt comfortable using that to build out the simulator.</p>

                <p>The core of the simulator is built around an object-oriented design with two main components: the GameSimulator class and a hierarchy of Tile objects. Each tile type (buildings, power plants, mud, spike traps, etc.) inherits from an abstract Tile class and implements its own behavior when a cat steps on it. For example, when a cat stomps a building, the building awards power based on its size (250 for small houses, 500 for big houses), destroys its top floor, and executes any command attached to that floor.</p>

                <div class="image-container">
                    <div style="display: flex; justify-content: center; gap: 20px;">
                        <div style="flex: 1; text-align: center;">
                            <img src="ml-post-images/commands.png" alt="Commands" style="max-width: 70%; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        </div>
                        <div style="flex: 1; text-align: center;">
                            <img src="ml-post-images/tiles.png" alt="Tiles" style="max-width: 70%; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        </div>
                    </div>
                    <div class="image-subtext">
                        Implementation of tile enums from the code
                    </div>
                </div>

                <p>The game runs for 15 turns. The movement system operates in three distinct phases.</p>
                <ul style="margin-left: 20px; margin-bottom: 20px;">
                    <li>ACTIVE state calculates where it wants to move based on its current direction. If a cat is facing EAST, it plans to move one tile to the right.</li>
                    <li>STUCK_MUD cats skip their movement but clear their stuck status for next turn</li>
                    <li>STOMPING cats stay in place to destroy the next floor of their current building.</li>
                </ul>

                <div class="image-container">
                    <img src="ml-post-images/active.png" alt="Active State" style="max-width: 70%;">
                    <div class="image-subtext">
                        Snippet from the code showing how the turn simulation works
                    </div>
                </div>

                <p>The second phase is collision detection and movement resolution. When a cat tries to move, the simulator first checks if the target tile is passable. Walls (represented by #) and boulders (X) are impassable, so if a cat tries to move into one, it immediately reverses direction. If multiple cats try to move to the same tile in the same turn, there's a fight. The winner is determined first by current power. If there's a tie in power, hierarchy breaks it: Blue beats Red beats Green.</p>

                <div class="image-container">
                    <video autoplay loop muted playsinline style="max-width: 100%; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <source src="ml-post-images/fighting.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <div class="image-subtext">
                        Example of an edge case: what if two cats of the same power land on the same square?
                    </div>
                </div>

                <p>The third phase is where tile effects apply. Landing on a building causes the cat to stomp it and power is gained based on the building. The cat destroys the top floor, and executes any command attached to that floor. The simulation can end early if all cats either reach:</p>
                <ul style="margin-left: 20px; margin-bottom: 20px;">
                    <li>FINISHED status (made it to their bed)</li>
                    <li>DEFEATED status (lost all their power)</li>
                </ul>
                <p>Otherwise it runs for exactly 15 turns.</p>

                <p>And here is how I structured the input and output:</p>

                <div class="image-container">
                    <img src="ml-post-images/starting_positions.png" alt="Starting Positions" style="max-width: 70%;">
                </div>

                <div class="image-container">
                    <img src="ml-post-images/movements.png" alt="Movements" style="max-width: 70%;">
                </div>

                <p>After running the simulator and comparing the output and intermediate steps with the real Kaiju game, tweaking the simulator a bit as I found small bugs, I ultimately ended up getting something that worked perfectly.</p>

                <div class="image-container">
                    <img src="ml-post-images/pretty_terminal.png" alt="Pretty Terminal Output" style="max-width: 70%;">
                    <div class="image-subtext">
                        Once I got it working on basic terminal output and verified the solutions, I got Claude to add some cool color elements to make it look pretty in the terminal.
                    </div>
                </div>

                <h2 id="ml">The Machine Learning</h2>

                <p>This was ultimately the make or break of this project. The number of possibilities was enormous. I had to rule out a few algorithms from the start. Because there was no adversary in this exercise, we could not use alpha-beta pruning like chess algorithms commonly use. Also since there is really no way to label data (and no efficient way to do so), approaches like Random Forest or K-nearest neighbors would not work.</p>

                <p>Bouncing around ideas with my friend Kevin, we ultimately decided simulated annealing would work best. The idea behind simulated annealing is like the real metallurgical process: heat everything up and let it cool down. By heating everything up, we mean trying a lot of random possibilities across a lot of different sequence types. Then by cooling down, we mean narrowing in on what worked best and optimizing that.</p>

                <p>Simulated annealing works well here because of the nature of the game. The game has a lot of "good but not great" solutions. Solutions that get you 30-40k points, but are far from the optimal solution. However, usually once you find some 30-40k solution, you can usually optimize it better to get a better score of around 70-80k. The advantage of simulated annealing was that you can try a lot of different paths, find some "good but not great solutions" and then the cool down would be able to optimize it.</p>

                <p>So that's exactly what I did. I created a basic simulating annealing algorithm.</p>

                <div class="image-container">
                    <img src="ml-post-images/SA.gif" alt="Simulated Annealing Visualization" style="max-width: 70%;">
                    <div class="image-subtext">
                        Visualization of simulated annealing (credit: https://medium.com/data-science/an-introduction-to-a-powerful-optimization-technique-simulated-annealing-87fd1e3676dd)
                    </div>
                </div>

                <h3>Pure Simulated Annealing</h3>

                <p>My first implementation followed the textbook simulated annealing approach with absolutely no heuristics or domain knowledge. The algorithm started with an empty solution (no commands placed) and iteratively improved it through random mutations. At each step, it would randomly choose to either<br>
                (1) remove a command<br>
                (2) add a new random command to any valid tile<br>
                (3) modify an existing command<br>
                (4) make 2-3 changes at once.</p>

                <p>The acceptance criterion was pure simulated annealing: always accept better solutions, and accept worse solutions with probability e<sup>(score/temperature)</sup>. The temperature started extremely high (100,000) and cooled very slowly over millions of iterations, with an automatic restart mechanism that would reset from scratch every 10,000 iterations without improvement.</p>

                <p>But‚Ä¶..the results were consistently disappointing. The algorithm would quickly climb from 0 to around 30,000-40,000 points in the first thousand iterations, then slowly creep up to 45,000-50,000 over the next few thousand iterations, before completely flatlining. Different runs would converge to different mediocre solutions, usually in the 40k-50k range, with occasional lucky runs hitting 60k-70k.</p>

                <p>Given that high scores for this game can get up to 100k+, this was just not good enough.</p>

                <p>After some time struggling with why this wasn't working, I realized this failure came down to a mismatch between how simulated annealing explores and what this problem actually required. First, the search space was absolutely massive. Most random command placements produced terrible scores because random turns would send cats into walls or spike traps, random powerups would be placed where cats never walked, and random stomps would destroy buildings cats needed for navigation. The algorithm spent the vast majority of its time wandering through the wasteland of 5k-30k score solutions, occasionally stumbling onto the 40k-50k "mediocre plateau" where one cat successfully reached its bed.</p>

                <p>But the real killer was that single-command mutations were far too small to escape these plateaus. Getting from 40k to 100k+ required coordinated changes, not just pure random simulation. If you wanted three cats in bed to trigger the 3x and 5x multipliers, it meant building paths that required 3-5 turn commands working together and cats making it far into the playing field.</p>

                <p>Without any heuristic, the search wandered aimlessly through the plateau. The cooling schedule made things worse: escaping a 40k local maximum to reach the 120k+ global maximum often required temporarily dropping to 20k-30k while rearranging commands, but once the temperature dropped low enough, the algorithm refused to make these necessary sacrifices.</p>

                <div class="image-container">
                    <img src="ml-post-images/cats.png" alt="Cats" style="max-width: 70%;">
                </div>

                <h3>The Optimization</h3>

                <p>After the disappointing results from the naive approach, I took a step back.</p>

                <p>How did I find good solutions when I played the game?<br>
                Getting all the cats in the bed. This is a sure way to get a "pretty good" score, since that last cat gets a 5x multiplier. All pretty good to amazing scores had all cats in the bed.</p>

                <p>So instead of using just score, I created new way to compare outcomes of simulated annealing:</p>

                <div style="background: #f5f5f5; padding: 16px; border-radius: 4px; margin: 20px 0; border-left: 3px solid #ddd;">
                    <p style="margin: 0; font-size: 16px;">fitness = score - (total_distance_to_beds √ó 500)</p>
                </div>

                <p>The idea was to penalize the routes that did not lead cats closer to their beds. Now a 40k solution with cats close to beds (distance=5, fitness=37,500) was seen as significantly better than a 40k solution with cats far away (distance=20, fitness=30,000), even though they had identical game scores.</p>

                <p>In essence, this new heuristic would "pull" the simulated annealing towards the solutions where the cats became closer and closer to the beds.</p>

                <div class="image-container">
                    <img src="ml-post-images/arrows.png" alt="Arrows showing optimization direction" style="max-width: 90%;">
                </div>

                <p>The algorithm gained a gradient to follow. It could "see" progress toward the goal even when the score was stuck. Crucially, this gave the algorithm patience during rearrangements: when modifying commands to build a better path, the score might temporarily drop, but if cats were getting closer to beds overall, the fitness would improve and the change would be accepted.</p>

                <p>Then a small change was to adjust cooling for a number of iterations. So a 1 minute run would cool faster than a 5 minute run.</p>

                <p>The results were dramatic. Where the naive approach consistently stalled at 40k-50k, the new approach had its first run of a score of 121,000!!</p>

                <p>The distance heuristic guided the search toward regions where all three cats could reach their beds, unlocking the massive score multipliers (3√ó for second arrival, 5√ó for third arrival) that made 100k+ scores possible.</p>

                <p>The idea for this optimization actually is the same heuristic which guides algorithms like Google Maps to find the best solution. That's a separate topic but I have a whole site exploring how that works. In this case the pure simulated annealing was like BFS, and the optimization was like A*.</p>

                <div class="image-container">
                    <div style="display: flex; justify-content: center; gap: 20px;">
                        <div style="flex: 1; text-align: center;">
                            <video autoplay loop muted playsinline style="max-width: 100%; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                                <source src="ml-post-images/bfs.mp4" type="video/mp4">
                                Your browser does not support the video tag.
                            </video>
                            <div style="margin-top: 10px; font-weight: 600;">BFS</div>
                        </div>
                        <div style="flex: 1; text-align: center;">
                            <video autoplay loop muted playsinline style="max-width: 100%; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                                <source src="ml-post-images/a_.mp4" type="video/mp4">
                                Your browser does not support the video tag.
                            </video>
                            <div style="margin-top: 10px; font-weight: 600;">A*</div>
                        </div>
                    </div>
                    <div class="image-subtext">
                        From <a href="https://secretsofmaps.com" style="color: #666; text-decoration: underline;">secretsofmaps.com</a>, a site I built to teach people how Google Maps works
                    </div>
                </div>

                <h3>The Final Optimization</h3>

                <p>While my algorithm could find great scores of 120k or even 140k, it still wasn't the best. How did I know this? Me and my friends could usually find a better solution if we worked together.</p>

                <p>I started looking through the output of the simulated annealing. I realized for a 10 minute run, a best score was usually found in the first minute or two. Then it never changed. What was happening is that the algorithm was getting "stuck" in local maxima and never exploring the better maximas.</p>

                <div class="image-container">
                    <img src="ml-post-images/SA.gif" alt="Simulated Annealing Visualization" style="max-width: 70%;">
                </div>

                <div class="image-container">
                    <img src="ml-post-images/stuck.png" alt="Algorithm Stuck in Local Maxima" style="max-width: 70%;">
                    <div class="image-subtext">
                        The algorithm would cool down and find a good solution, but only one that was locally optimal
                    </div>
                </div>

                <p>So instead of doing a full 10 minute run and letting it cool down too much to where it was exploring too many unviable paths, I did runs of smaller time frames to get more "random starts". This would allow me to explore a bunch of different paths instead of just one path, but very widely. I messed around with different times on the same map and I found 5 seconds was too short (good paths weren't fully discovered). And then 10 seconds and 15 seconds gave roughly the same results.</p>

                <div class="image-container">
                    <img src="ml-post-images/not_complete.png" alt="Not Complete" style="max-width: 70%;">
                </div>

                <div class="image-container">
                    <img src="ml-post-images/10s.png" alt="10 Second Runs" style="max-width: 70%;">
                </div>

                <p>By restarting from a random point many times, the algorithm was able to get a better chance of finding those 150k+ divots. By also adding multithreading (running these random points in unison on multiple CPU threads), I greatly expanded my computational power. And with that, I was getting scores that were really good. I mean really really good.</p>

                <h2 id="results">Results</h2>

                <div class="image-container">
                    <video autoplay loop muted playsinline style="max-width: 100%; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <source src="ml-post-images/playthrough.mp4" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                    <div class="image-subtext">
                        A playthrough of the game using the algorithm
                    </div>
                </div>

                <p>I did 10 test runs with the final version of simulated annealing, giving my algorithm about 10 minutes of compute, with 5 minutes reserved for me to be able to input the game map into my program and then copy the program's results back into the game.</p>

                <p>Hardware: Macbook Air M2 (2022)<br>
                Compute Time: ~10 minutes<br>
                Paths Explored each Time: ~50,000,000 (a small fraction of 6<sup>31</sup> possibilities)</p>

                <h2 id="video-results">Putting it to the Test</h2>

                <p>Here is a sequence of 10 consecutive runs of my algorithm to give you an idea of how it performs over a wide range of maps:</p>

                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 30px; margin: 40px 0;">
                    <div style="text-align: center;">
                        <video autoplay loop muted playsinline style="width: 100%; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <source src="ml-post-images/results/s1.mp4" type="video/mp4">
                        </video>
                        <div style="margin-top: 12px; font-size: 18px; font-weight: 600;">Score: 155,125</div>
                    </div>

                    <div style="text-align: center;">
                        <video autoplay loop muted playsinline style="width: 100%; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <source src="ml-post-images/results/s2.mp4" type="video/mp4">
                        </video>
                        <div style="margin-top: 12px; font-size: 18px; font-weight: 600;">Score: 185,625</div>
                    </div>

                    <div style="text-align: center;">
                        <video autoplay loop muted playsinline style="width: 100%; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <source src="ml-post-images/results/s3.mp4" type="video/mp4">
                        </video>
                        <div style="margin-top: 12px; font-size: 18px; font-weight: 600;">Score: 97,000</div>
                    </div>

                    <div style="text-align: center;">
                        <video autoplay loop muted playsinline style="width: 100%; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <source src="ml-post-images/results/s4.mp4" type="video/mp4">
                        </video>
                        <div style="margin-top: 12px; font-size: 18px; font-weight: 600;">Score: 215,000</div>
                    </div>

                    <div style="text-align: center;">
                        <video autoplay loop muted playsinline style="width: 100%; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <source src="ml-post-images/results/s5.mp4" type="video/mp4">
                        </video>
                        <div style="margin-top: 12px; font-size: 18px; font-weight: 600;">Score: 85,375</div>
                    </div>

                    <div style="text-align: center;">
                        <video autoplay loop muted playsinline style="width: 100%; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <source src="ml-post-images/results/s6.mp4" type="video/mp4">
                        </video>
                        <div style="margin-top: 12px; font-size: 18px; font-weight: 600;">Score: 197,375</div>
                    </div>

                    <div style="text-align: center;">
                        <video autoplay loop muted playsinline style="width: 100%; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <source src="ml-post-images/results/s7.mp4" type="video/mp4">
                        </video>
                        <div style="margin-top: 12px; font-size: 18px; font-weight: 600;">Score: 215,000</div>
                    </div>

                    <div style="text-align: center;">
                        <video autoplay loop muted playsinline style="width: 100%; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <source src="ml-post-images/results/s8.mp4" type="video/mp4">
                        </video>
                        <div style="margin-top: 12px; font-size: 18px; font-weight: 600;">Score: 134,625</div>
                    </div>

                    <div style="text-align: center;">
                        <video autoplay loop muted playsinline style="width: 100%; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <source src="ml-post-images/results/s9.mp4" type="video/mp4">
                        </video>
                        <div style="margin-top: 12px; font-size: 18px; font-weight: 600;">Score: 102,000</div>
                    </div>

                    <div style="text-align: center;">
                        <video autoplay loop muted playsinline style="width: 100%; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                            <source src="ml-post-images/results/s10.mp4" type="video/mp4">
                        </video>
                        <div style="margin-top: 12px; font-size: 18px; font-weight: 600;">Score: 204,125</div>
                    </div>
                </div>

                <p>My algorithm achieved the following scores across 10 consecutive runs:</p>

                <p style="text-align: center; font-family: monospace; line-height: 1.8;">
                155,125 | 185,625 | 97,000 | 215,000 | 85,375<br>
                197,375 | 215,000 | 134,625 | 102,000 | 204,125
                </p>

                <div class="highlight-box">
                    <strong>My Algorithm Performance:</strong><br>
                    Mean: 159,125 | Median: 191,500 | Std. Dev: 51,211<br><br>
                    <strong>Hardware:</strong> Macbook Air M2 (2022)<br>
                    <strong>Compute Time:</strong> ~10 minutes<br>
                    <strong>Paths Explored each Time:</strong> ~50,000,000
                </div>

                <p>To put this in perspective, based on <a href="https://educationaldatamining.org/edm2024/proceedings/2024.EDM-posters.96/index.html" style="color: inherit; text-decoration: underline;">data published by Roblox</a>, the average on-task submission score for candidates is 40,827 (¬± 21,056). My algorithm's mean score of 159,125 represents a <strong>2.9x improvement</strong> over the human average, playing better than 99.999999% of people.</p>

                <div class="highlight-box">
                    <strong>Statistical Significance:</strong><br>
                    Z-score = (159,125 - 40,827) / 21,056 = 5.62<br>
                    This places the algorithm in the top 0.000001% of players.<br>
                    In other words: if 8 billion people played this game, statistically only 79 would score higher.
                </div>

                <h2>Key Takeaways</h2>

                <p>The lesson here echoes a fundamental truth across AI: raw computational power needs guidance. Deep Blue didn't defeat Garry Kasparov through brute force alone. It had chess grandmasters encoding years of strategic knowledge into its evaluation function, teaching it that controlling the center matters and king safety is crucial.</p>

                <p>My simulated annealing optimizer followed the same arc. The naive version was directionless, wandering through mediocre 40k solutions. The distance heuristic, one simple insight that "cats near beds are valuable", transformed everything. It gave the algorithm vision, a way to recognize progress even when scores plateaued. Results improved 2-3x almost immediately, jumping from 40k-50k to 100k-120k+. Then with testing and observation of the simulated annealing, tweaking the core algorithm allowed for the performance to find the truly high results.</p>

                <h2 id="ethics">Ethics Disclaimer</h2>

                <p>I never used this algorithm to cheat on Roblox's assessment. I developed it much later after I took the assessment. However, I am 99%+ confident this algorithm could pass the Roblox interview Kaiju Cats game. As much as I love sharing my ideas with people, to prevent applicants from using this to cheat on the actual Roblox assessment, I have decided to keep this Github repo private.</p>

                <p>While I didn't end up making it through the entire Roblox process, I ended up learning a lot about ML.</p>

                <div class="image-container">
                    <img src="ml-post-images/passing.png" alt="Passing" style="max-width: 70%;">
                </div>

                <h2>Could LLMs do better?</h2>

                <p>I decided to see if AI could do better. After I gave Claude the context of the game and the rules I prompted: "Be free, you no longer need to use simulated annealing. Find the best algorithm: it can be either improving my simulated annealing or a completely new approach. I expect a score of 100k+ within 5 minutes of computation."</p>

                <p>Claude came up with an elaborate Genetic algorithm and I wrote some code to test it. The results: extremely disappointing. Claude's best approach: Genetic Mutation Algorithm.</p>

                <p><strong>Population:</strong> Start with 200 random solutions<br>
                <strong>Selection:</strong> Pick best solutions as "parents" (survival of fittest)<br>
                <strong>Crossover:</strong> Combine two parents to create "child" solution<br>
                <strong>Mutation:</strong> Randomly change some children<br>
                <strong>Repeat:</strong> Evolve for 2000 generations</p>

                <p>Best scores: 20k-30k range</p>

                <p>While LLMs are good for formatting and basic code, they struggle to understand games that require intuition.</p>

                <h2>Other Potential Ideas</h2>

                <p>Maximizing the number of powerplants one cat could get. In the very best scores, you "sacrifice" the 2 cats in the bed as fast as possible and then take the last cat and try to get the maximum score and the maximum number of powerplants with that cat. I briefly tried doing this, but with little improvements.</p>

                <div style="background: #f9f9f9; border: 1px solid #e5e5e5; border-radius: 8px; padding: 30px; margin: 50px 0 30px 0; display: flex; align-items: center; gap: 25px;">
                    <img src="../profile.JPG" alt="Adam Kulikowski" style="width: 100px; height: 100px; border-radius: 50%; object-fit: cover; object-position: 15% center; flex-shrink: 0;">
                    <div>
                        <p style="margin: 0 0 12px 0; font-size: 16px;">I'm <strong>Adam Kulikowski</strong>, a Computer Science student at Georgia Tech passionate about software engineering and machine learning.</p>
                        <a href="../index.html" style="color: #666; text-decoration: underline; font-size: 15px;">‚Üê Return to Main</a>
                    </div>
                </div>

                <div class="footer-note">
                    Thanks for reading. If you have questions or want to chat about ML, feel free to reach out on <a href="https://linkedin.com/in/adamkulikowski">LinkedIn</a> or <a href="mailto:adamkul0126@gmail.com">email</a>.
                </div>
            </div>
        </article>
    </div>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-S0SMWRSS73"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-S0SMWRSS73');
    </script>
</body>
</html>
